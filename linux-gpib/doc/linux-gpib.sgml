<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN"
	"docbook/dtd/4.1/docbook.dtd"[
<!ENTITY license SYSTEM "fdl.xml">
]>

<article>

<articleinfo>
<title>
	Linux-GPIB Documentation
</title>

<author>
	<firstname>Frank</firstname>
	<othername>Mori</othername>
	<surname>Hess</surname>
	<affiliation>
	<address>
		fmhess@users.sourceforge.net
	</address>
	</affiliation>
</author>

<copyright>
<year>2003</year>
<holder>Frank Mori Hess</holder>
</copyright>
</articleinfo>

<section>
<title>
	Copying
</title>
<para>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
<link LINKEND="gfdl">"GNU Free Documentation License"</link>.
</para>
</section>

<section ID="reference">
<title>
	Linux-GPIB Reference
</title>
<para>
	Reference for libgpib functions, macros, and constants.
</para>
<section>
<title>Global Variables</title>

<refentry ID="reference-globals-ibsta">
<refmeta>
	<refentrytitle>ibsta</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsta</refname>
	<refpurpose>holds status (device or board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int ibsta;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibsta is set whenever a function from the 'traditional' or 'multidevice'
	API is called.  Each of the bits in ibsta has a different meaning, summarized
	in the following table:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>ibsta Bits</title>
	<tgroup COLS="4" ALIGN="left" >
	<thead>
	<row>
	<entry>bit</entry>
	<entry>value (hexadecimal)</entry>
	<entry>meaning</entry>
	<entry>used for board/device</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>DCAS</entry>
	<entry>0x1</entry>
	<entry>DCAS is set when a board receives the device clear command
	(that is, the
	SDC or DCL <link LINKEND="reference-command-bytes">command byte</link>).
	It is cleared on the next 'traditional' or
	'multidevice' function call following ibwait(), or following a read
	or write (ibrd(), ibwrt(), Receive(), etc.).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>DTAS</entry>
	<entry>0x2</entry>
	<entry>DTAS is set when a board has received a device trigger command
	(that is,
	the GET <link LINKEND="reference-command-bytes">command byte</link>).
	It is cleared on the next 'traditional' or
	'multidevice' function call following ibwait(), or following a read
	or write (ibrd(), ibwrt(), Receive(), etc.).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>LACS</entry>
	<entry>0x4</entry>
	<entry>Board is currently addressed as a listener.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>TACS</entry>
	<entry>0x8</entry>
	<entry>Board is currently addressed as talker.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>ATN</entry>
	<entry>0x10</entry>
	<entry>The ATN line is asserted.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>CIC</entry>
	<entry>0x20</entry>
	<entry>Board is controller-in-charge, so it is able to set the ATN line.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>REM</entry>
	<entry>0x40</entry>
	<entry>Board is in 'remote' state.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>LOK</entry>
	<entry>0x80</entry>
	<entry>Board is in 'lockout' state.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>CMPL</entry>
	<entry>0x100</entry>
	<entry>I/O operation is complete.  Useful for determining when
	an asynchronous io operation (ibrda(), ibwrta(), etc) has
	completed.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>EVENT</entry>
	<entry>0x200</entry>
	<entry>One or more clear, trigger, or interface clear events have been received,
	and are available in the event queue (see ibevent()).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>SPOLL</entry>
	<entry>0x400</entry>
	<entry>If this bit is enabled (see ibconfig()), it is set when the board is
	serial polled.  The SPOLL bit is cleared when the board requests service
	(see ibrsv()) or you call ibwait() on the board with SPOLL in the wait mask.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>RQS</entry>
	<entry>0x800</entry>
	<entry>RQS indicates that the device has requested service, and one
	or more status bytes are available for reading with ibrsp().</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>SRQI</entry>
	<entry>0x1000</entry>
	<entry>SRQI indicates that a device connected to the board is asserting
	the SRQ line.  It
	is only set if the board is the controller-in-charge.  If
	automatic serial polling is enabled, SRQI will generally be cleared,
	since when a device requests service it will be automatically
	polled and then unassert SRQ.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>END</entry>
	<entry>0x2000</entry>
	<entry>END is set if the last io operation ended with the EOI
	line asserted, and may be set on reception of the end-of-string character.
	The
	IbcEndBitIsNormal option of ibconfig() can be used to configure
	whether or not END should be set on reception of the eos character.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>TIMO</entry>
	<entry>0x4000</entry>
	<entry>TIMO indicates that the last io operation or ibwait() timed out.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>ERR</entry>
	<entry>0x8000</entry>
	<entry>ERR is set if the last 'traditional' or 'multidevice' function
	call failed.  The global variable iberr will be set indicate the
	cause of the error.</entry>
	<entry>board or device</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
</refentry>

</section>

<section>
<title>
	'Traditional' API Functions
</title>

<refentry ID="reference-function-ibdev">
<refmeta>
	<refentrytitle>ibdev</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibdev</refname>
	<refpurpose>open a device (device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibdev</function></funcdef>
		<paramdef>int <parameter>board_index</parameter></paramdef>
		<paramdef>int <parameter>pad</parameter></paramdef>
		<paramdef>int <parameter>sad</parameter></paramdef>
		<paramdef>int <parameter>timeout</parameter></paramdef>
		<paramdef>int <parameter>send_eoi</parameter></paramdef>
		<paramdef>int <parameter>eos</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibdev() is used to obtain a device descriptor, which can then be used by
	other functions in the library.  The argument <parameter>board_index</parameter>
	specifies which GPIB interface board the device is connected to.
	The <parameter>pad</parameter> and <parameter>sad</parameter> arguments specify
	the GPIB address of the device to be opened (see <link LINKEND="reference-function-ibpad">
	ibpad()</link> and <link LINKEND="reference-function-ibsad">ibsad()</link>).
	The timeout for io operations is specified by <parameter> timeout </parameter>
	(see <link LINKEND="reference-function-ibtmo">ibtmo()</link>). If
	<parameter>send_eoi</parameter> is nonzero, then the EOI
	line will be asserted with the last byte sent during writes (see
	<link LINKEND="reference-function-ibeot">ibeot()</link>).
	Finally, the <parameter>eos</parameter>
	argument specifies the end-of-string character and whether or not its
	reception should terminate reads (see <link LINKEND="reference-function-ibeos">
	ibeos()</link>).
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	If sucessful, returns a (non-negative) device descriptor.  On failure, -1 is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibeos">
<refmeta>
	<refentrytitle>ibeos</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibeos</refname>
	<refpurpose>set end-of-string mode (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibeos</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>eosmode</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibeos() is used to set the end-of-string character and mode.  The least
	significant 8 bits of <parameter>eosmode</parameter> specify the
	eos character.  You may also bitwise-or one or more of the following
	bits to set the eos mode:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>End-of-String Mode Bits</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value (hexadecimal)</entry>
	<entry>meaning</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>REOS</entry>
	<entry>0x400</entry>
	<entry>Enable termination of reads when eos character is received.</entry>
	</row>
	<row>
	<entry>XEOS</entry>
	<entry>0x800</entry>
	<entry>Assert the EOI line whenever the eos character is sent during writes.</entry>
	</row>
	<row>
	<entry>BIN</entry>
	<entry>0x1000</entry>
	<entry>Match eos character using all 8 bits (instead of only looking at
	the 7 least significant bits).</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibeot">
<refmeta>
	<refentrytitle>ibeot</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibeot</refname>
	<refpurpose>assert EOI with last data byte (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibeot</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>send_eoi</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If <parameter>send_eoi</parameter> is non-zero, then the EOI
	line will be asserted with the last byte sent by
	calls to <link LINKEND="reference-function-ibwrt">ibwrt()</link>
	and related functions.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibpad">
<refmeta>
	<refentrytitle>ibpad</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibpad</refname>
	<refpurpose>set primary GPIB address (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibpad</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>pad</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibpad()
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrd">
<refmeta>
	<refentrytitle>ibrd</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrd</refname>
	<refpurpose>read data bytes (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrd</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>void* <parameter>buffer</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibrd() is used to read data bytes from a device or board.  The argument
	<parameter>ud</parameter> can be either a device or board descriptor.
	If <parameter>ud</parameter> is a device descriptor, then the library
	automatically handles addressing the device as talker and the interface
	board as listener before performing the read.  Up to
	<parameter>num_bytes</parameter> bytes
	are read into the user-supplied array <parameter>buffer</parameter>.  The
	read may be terminated by an end-of-string character (see
	<link LINKEND="reference-function-ibeos">ibeos()</link>), a
	timeout (see <link LINKEND="reference-function-ibtmo">ibtmo()</link>),
	or by the talker asserting the EOI line.
	</para>
	<para>
	After the ibrd() call, ibcnt and ibcntl are set to the number of bytes
	read.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibsad">
<refmeta>
	<refentrytitle>ibsad</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsad</refname>
	<refpurpose>set secondary GPIB address (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibsad</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>sad</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibsad()
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibtmo">
<refmeta>
	<refentrytitle>ibtmo</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibtmo</refname>
	<refpurpose>adjust io timeout (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibtmo</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>timeout</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibtmo()
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibwrt">
<refmeta>
	<refentrytitle>ibwrt</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibwrt</refname>
	<refpurpose>write data bytes (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibwrt</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>void* <parameter>buffer</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibwrt() is used to write data bytes to a device or board.  The argument
	<parameter>ud</parameter> can be either a device or board descriptor.
	If <parameter>ud</parameter> is a device descriptor, then the library
	automatically handles addressing the device as listener and the interface
	board as talker before performing the write.
	<parameter>num_bytes</parameter> bytes
	are written from the user-supplied array <parameter>buffer</parameter>.
	EOI may be asserted with the last byte sent or when the end-of-string
	character is sent (see <link LINKEND="reference-function-ibeos">
	ibeos()</link> and <link LINKEND="reference-function-ibeot">
	ibeot()</link>).  The write
	may be interrupted by a timeout (see <link LINKEND="reference-function-ibtmo">
	ibtmo()</link>).
	</para>
	<para>
	After the ibwrt() call, ibcnt and ibcntl are set to the number of bytes
	written.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

</section>

</section>

<section>
<title>GPIB protocol</title>

<section ID="reference-command-bytes">
	<title>GPIB command bytes</title>
	<para>
	The meaning and values of the possible GPIB command bytes
	are as follows:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>GPIB command bytes</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value (hexadecimal)</entry>
	<entry>description</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry></entry>
	<entry></entry>
	<entry></entry>
	</tbody>
	</tgroup>
	</table>
	</para>
</section>

<section>
<title>GPIB bus lines</title>
<para></para>
</section>

</section>

&license

</article>

