<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN"
	"docbook/dtd/4.1/docbook.dtd"[
<!ENTITY license SYSTEM "fdl.xml">
]>

<article>

<articleinfo>
<title>
	Linux-GPIB Documentation
</title>

<author>
	<firstname>Frank</firstname>
	<othername>Mori</othername>
	<surname>Hess</surname>
	<affiliation>
	<address>
		fmhess@users.sourceforge.net
	</address>
	</affiliation>
</author>

<copyright>
<year>2003</year>
<holder>Frank Mori Hess</holder>
</copyright>
</articleinfo>

<section>
<title>
	Copying
</title>
<para>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
<link LINKEND="gfdl">"GNU Free Documentation License"</link>.
</para>
</section>

<section ID="configuration">
<title>
	Configuration: gpib.conf
</title>
<para>
The library reads its configuration information from the
file /etc/gpib.conf.  An alternate file path for the configuration information
can be specified
by setting the IB_CONFIG environment variable.  A template gpib.conf
file can be found in the util/templates/ subdirectory of the linux-gpib
package.
</para>
<para>
The configuration file must contain one or more 'interface' entries, and
can contain zero or more 'device' entries.  'device' entries are only
required if you wish to open device descriptors with
<link LINKEND="reference-function-ibfind">ibfind()</link> instead
of using <link LINKEND="reference-function-ibdev">ibdev()</link>.
Several example entries, and a table summarizing the possible
options follow.
</para>
<para>
<programlisting>

interface {
	minor = 0
	board_type = "ni_pci"
	pad = 0
	master = yes
}

interface {
	minor = 1
	board_type = "ines_pci_accel"
	name = "joe"
	pad = 5
	sad = 0
	timeout = T10s
	pci_bus = 0
	pci_slot = 0xd
	master = no
}

interface {
	minor = 2
	board_type = "pcII"
	pad = 3
	sad = 0x62
	eos = 0x0d
	set-reos = yes
	set-bin = no
	set-xeos = no
	set-eot = yes
	base = 0x300
	irq  = 5
	dma  = 0
	master = no
}

device {
	minor = 0
	name = "counter"
	pad = 24
}

device {
	minor = 0
	name = "voltmeter"
	pad = 7
	sad = 110
	eos = 0xa
	set-reos = yes
	set-bin = no
	set-xeos = yes
	set-eot = no
	timeout = T1s
}

</programlisting>
</para>
<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>configuration options</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>option name</entry>
	<entry>description</entry>
	<entry>used by interface or device entries</entry>
	<entry>required or optional</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>base</entry>
	<entry>Specifies the base ioport or io memory address for a
	board that lacks plug-and-play capability.</entry>
	<entry>interface</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>board_type</entry>
	<entry>Specifies the type of interface board.  See the drivers.txt
	file for a list of possible board types, and the kernel driver
	module that supports them.</entry>
	<entry>interface</entry>
	<entry>required</entry>
	</row>
	<row>
	<entry>dma</entry>
	<entry>Specifies the dma channel for a board that lacks plug-and-play
	capability.</entry>
	<entry>interface</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>eos</entry>
	<entry>Sets the end-of-string byte for board or device descriptors
	obtained with ibfind().  See also the set-reos, set-bin, and set-xeos
	options.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>irq</entry>
	<entry>Specifies the interrupt level for a board that lacks
	plug-and-play capability.</entry>
	<entry>interface</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>master</entry>
	<entry>Set to 'yes' if you want the interface board to
	be the system controller of the bus.  There can only
	be one system controller on a bus.</entry>
	<entry>interface</entry>
	<entry>required</entry>
	</row>
	<row>
	<entry>minor</entry>
	<entry>'minor' specifies the minor number of the device file this
	interface board will use.  A 'minor' of 0 corresponds
	to /dev/gpib0, 1 is /dev/gpib1, etc.  The minor number is also
	equal to the 'board index' which can be used as a board descriptor,
	and is passed as one of the arguments of <link LINKEND="reference-function-ibdev">
	ibdev()</link>
	</entry>
	<entry>interface</entry>
	<entry>required</entry>
	</row>
	<row>
	<entry>name</entry>
	<entry>The 'name' specifies the name which can be used with ibfind()
	to get a descriptor for the board or device associated with this entry.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>pad</entry>
	<entry>Specifies the primary GPIB address (valid addresses are 0 to 30).
	For interfaces, this is the primary address that the board will be
	assigned when it is first brought online.  For devices, this is address
	that will be used by device descriptors obtained with ibfind().</entry>
	<entry>interface or device</entry>
	<entry>required</entry>
	</row>
	<row>
	<entry>pci_bus</entry>
	<entry>Useful for distinguishing between multiple PCI cards.  If
	you have more than one PCI card that with the same 'board_type', you can
	use the 'pci_bus' and 'pci_slot' options to specify the particular
	card you are interested in.  </entry>
	<entry>interface</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>pci_slot</entry>
	<entry>Can be used in conjunction with 'pci_bus' to specify
	a particular pci card.</entry>
	<entry>interface</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>sad</entry>
	<entry>Specifies the secondary GPIB address.  Valid values are 0, or
	0x60 to 0x7e hexadecimal (96 to 126 decimal).  A value of 0 means
	secondary addressing is disabled (the default).  Secondary addresses
	from 0 to 30
	are specified by the library's convention of adding an offset of 0x60.
	</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>set-bin</entry>
	<entry>Enables 8-bit comparisons when matching the
	end-of-string byte, instead of only comparing the
	7 least significant bits.  Only affects descriptors
	returned by ibfind(), and has same effect as setting
	the BIN bit in a
	<link LINKEND="reference-function-ibeos">ibeos()</link>
	call.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>set-eot</entry>
	<entry>Enables assertion of the EOI line at the
	end of writes, for descriptors
	returned by ibfind().  See
	<link LINKEND="reference-function-ibeot">ibeot()</link>.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>set-reos</entry>
	<entry>Enables the termination of reads on reception of the
	end-of-string byte for descriptors returned by ibfind().
	Same as setting the REOS bit in a
	<link LINKEND="reference-function-ibeos">ibeos()</link>
	call.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>set-xeos</entry>
	<entry>Enables the assertion of EOI on transmission of the
	end-of-string byte for descriptors returned by ibfind().
	Same as setting the XEOS bit in a
	<link LINKEND="reference-function-ibeos">ibeos()</link>
	call.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	<row>
	<entry>timeout</entry>
	<entry>Sets the io timeout for a board or device descriptor opened through
	ibfind().  The possible settings are the same as the constants
	used by <link LINKEND="reference-function-ibtmo">ibtmo()</link>.</entry>
	<entry>interface or device</entry>
	<entry>optional</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
</para>
</section>

<section ID="reference">
<title>
	Linux-GPIB Reference
</title>
<para>
	Reference for libgpib functions, macros, and constants.
</para>
<section>
<title>Global Variables</title>

<refentry ID="reference-globals-ibcnt">
<refmeta>
	<refentrytitle>ibcnt and ibcntl</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibcnt and ibcntl</refname>
	<refpurpose>hold number of bytes transferred, or errno</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int ibcnt;
volatile long ibcntl;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibcnt and ibcntl are set after IO operations to the the the number of
	bytes sent or received.  They are also set to the value of errno after
	EDVR or EFSO errors.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-globals-iberr">
<refmeta>
	<refentrytitle>iberr</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>iberr</refname>
	<refpurpose>holds error code</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int iberr;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	iberr is set whenever a function from the 'traditional' or 'multidevice'
	API fails with an error.  The meaning of each possible value of iberr
	is summarized
	in the following table:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>iberr error codes</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value</entry>
	<entry>meaning</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>EDVR</entry>
	<entry>0</entry>
	<entry>A system call has failed.  ibcnt/ibcntl will be set to the
	value of errno.</entry>
	</row>
	<row>
	<entry>ECIC</entry>
	<entry>1</entry>
	<entry>Your interface board needs to be controller-in-charge, but
	is not.</entry>
	</row>
	<row>
	<entry>ENOL</entry>
	<entry>2</entry>
	<entry>You have attempted to write data or command bytes, but
	there are no listeners currently addressed.</entry>
	</row>
	<row>
	<entry>EADR</entry>
	<entry>3</entry>
	<entry>The interface board has failed to address itself properly
	before starting an io operation.</entry>
	</row>
	<row>
	<entry>EARG</entry>
	<entry>4</entry>
	<entry>One or more arguments to the function call were invalid.</entry>
	</row>
	<row>
	<entry>ESAC</entry>
	<entry>5</entry>
	<entry>The interface board needs to be system controller, but is not.
	</entry>
	</row>
	<row>
	<entry>EABO</entry>
	<entry>6</entry>
	<entry>A read or write of data bytes has been aborted, possibly due
	to a timeout or reception of a device clear command.</entry>
	</row>
	<row>
	<entry>ENEB</entry>
	<entry>7</entry>
	<entry>The GPIB interface board does not exist, its driver is not
	loaded, or it is not configured properly.</entry>
	</row>
	<row>
	<entry>EDMA</entry>
	<entry>8</entry>
	<entry>Not used (DMA error), included for compatibility purposes.</entry>
	</row>
	<row>
	<entry>EOIP</entry>
	<entry>10</entry>
	<entry>Function call can not proceed due to an asynchronous IO operation
	(ibrda(), ibwrta(), or ibcmda()) in progress.</entry>
	</row>
	<row>
	<entry>ECAP</entry>
	<entry>11</entry>
	<entry>Incapable of executing function call, due the GPIB board lacking
	the capability, or
	the capability being disabled in software.</entry>
	</row>
	<row>
	<entry>EFSO</entry>
	<entry>12</entry>
	<entry>File system error.  ibcnt/ibcntl will be set to the value of errno.</entry>
	</row>
	<row>
	<entry>EBUS</entry>
	<entry>14</entry>
	<entry>An attempt to write command bytes to the bus has timed out.</entry>
	</row>
	<row>
	<entry>ESTB</entry>
	<entry>15</entry>
	<entry>One or more serial poll status bytes have been lost.  This can
	occur due to
	too many status bytes accumulating (through automatic serial polling)
	without being read.</entry>
	</row>
	<row>
	<entry>ESRQ</entry>
	<entry>16</entry>
	<entry>The serial poll request service line is stuck on.  This can occur
	if a physical device on the bus requests service, but its GPIB address has
	not been opened
	(via ibdev() for example) by any process.  Thus the automatic serial
	polling routines are unaware of the device's existence and will never
	serial poll it.
	</entry>
	</row>
	<row>
	<entry>ETAB</entry>
	<entry>20</entry>
	<entry>This error can be returned by
	<link LINKEND="reference-function-ibevent">ibevent()</link>, FindLstn(), or
	FindRQS().  See their descriptions for more information.</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
</refentry>

<refentry ID="reference-globals-ibsta">
<refmeta>
	<refentrytitle>ibsta</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsta</refname>
	<refpurpose>holds status</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int ibsta;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibsta is set whenever a function from the 'traditional' or 'multidevice'
	API is called.  Each of the bits in ibsta has a different meaning, summarized
	in the following table:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>ibsta Bits</title>
	<tgroup COLS="4" ALIGN="left" >
	<thead>
	<row>
	<entry>bit</entry>
	<entry>value (hexadecimal)</entry>
	<entry>meaning</entry>
	<entry>used for board/device</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>DCAS</entry>
	<entry>0x1</entry>
	<entry>DCAS is set when a board receives the device clear command
	(that is, the
	SDC or DCL <link LINKEND="reference-command-bytes">command byte</link>).
	It is cleared on the next 'traditional' or
	'multidevice' function call following ibwait(), or following a read
	or write (ibrd(), ibwrt(), Receive(), etc.).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>DTAS</entry>
	<entry>0x2</entry>
	<entry>DTAS is set when a board has received a device trigger command
	(that is,
	the GET <link LINKEND="reference-command-bytes">command byte</link>).
	It is cleared on the next 'traditional' or
	'multidevice' function call following ibwait(), or following a read
	or write (ibrd(), ibwrt(), Receive(), etc.).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>LACS</entry>
	<entry>0x4</entry>
	<entry>Board is currently addressed as a listener.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>TACS</entry>
	<entry>0x8</entry>
	<entry>Board is currently addressed as talker.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>ATN</entry>
	<entry>0x10</entry>
	<entry>The ATN line is asserted.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>CIC</entry>
	<entry>0x20</entry>
	<entry>Board is controller-in-charge, so it is able to set the ATN line.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>REM</entry>
	<entry>0x40</entry>
	<entry>Board is in 'remote' state.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>LOK</entry>
	<entry>0x80</entry>
	<entry>Board is in 'lockout' state.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>CMPL</entry>
	<entry>0x100</entry>
	<entry>I/O operation is complete.  Useful for determining when
	an asynchronous io operation (ibrda(), ibwrta(), etc) has
	completed.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>EVENT</entry>
	<entry>0x200</entry>
	<entry>One or more clear, trigger, or interface clear events have been received,
	and are available in the event queue
	(see <link LINKEND="reference-function-ibevent">ibevent()</link>).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>SPOLL</entry>
	<entry>0x400</entry>
	<entry>If this bit is enabled (see ibconfig()), it is set when the board is
	serial polled.  The SPOLL bit is cleared when the board requests service
	(see ibrsv()) or you call ibwait() on the board with SPOLL in the wait mask.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>RQS</entry>
	<entry>0x800</entry>
	<entry>RQS indicates that the device has requested service, and one
	or more status bytes are available for reading with ibrsp().</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>SRQI</entry>
	<entry>0x1000</entry>
	<entry>SRQI indicates that a device connected to the board is asserting
	the SRQ line.  It
	is only set if the board is the controller-in-charge.  If
	automatic serial polling is enabled, SRQI will generally be cleared,
	since when a device requests service it will be automatically
	polled and then unassert SRQ.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>END</entry>
	<entry>0x2000</entry>
	<entry>END is set if the last io operation ended with the EOI
	line asserted, and may be set on reception of the end-of-string character.
	The
	IbcEndBitIsNormal option of ibconfig() can be used to configure
	whether or not END should be set on reception of the eos character.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>TIMO</entry>
	<entry>0x4000</entry>
	<entry>TIMO indicates that the last io operation or ibwait() timed out.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>ERR</entry>
	<entry>0x8000</entry>
	<entry>ERR is set if the last 'traditional' or 'multidevice' function
	call failed.  The global variable <link LINKEND="reference-globals-iberr">iberr</link>
	 will be set indicate the
	cause of the error.</entry>
	<entry>board or device</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
</refentry>

</section>

<section>
<title>
	'Traditional API' Functions
</title>

<refentry ID="reference-function-ibask">
<refmeta>
	<refentrytitle>ibask</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibask</refname>
	<refpurpose>query configuration (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibask</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>option</parameter></paramdef>
		<paramdef>int *<parameter>result</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	Queries various configuration settings associated with the
	board or device descriptor <parameter>ud</parameter>.  The
	<parameter>option</parameter> argument specifies the particular
	setting you wish to query.  The result of the query is written
	to the location specified by <parameter>result</parameter>.
	To change the descriptor's configuration, see
	<link LINKEND="reference-function-ibconfig">ibconfig()</link>.
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>ibask options</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>option</entry>
	<entry>value (hexadecimal)</entry>
	<entry>result of query</entry>
	<entry>used for board/device</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>IbaPAD</entry>
	<entry>0x1</entry>
	<entry>GPIB primary address</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaSAD</entry>
	<entry>0x2</entry>
	<entry>GPIB secondary address (0 for none, 0x60 to 0x7e for secondary
	addresses 0 to 30)</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaTMO</entry>
	<entry>0x3</entry>
	<entry>Timeout setting for io operations (a number from 0 to 17).  See
	<link LINKEND="reference-function-ibtmo">ibmto()</link>.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaEOT</entry>
	<entry>0x4</entry>
	<entry>Nonzero if EOI is asserted with last byte on writes.
	See <link LINKEND="reference-function-ibeot">ibeot()</link>.
	</entry>
	<entry></entry>
	</row>
	<row>
	<entry>IbaPPC</entry>
	<entry>0x5</entry>
	<entry>Parallel poll configuration.  See
	<link LINKEND="reference-function-ibppc">ibppc()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaREADDR</entry>
	<entry>0x6</entry>
	<entry>Useless, included for compatibility only.</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>IbaAUTOPOLL</entry>
	<entry>0x7</entry>
	<entry>Nonzero if automatic serial polling is enabled.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaCICPROT</entry>
	<entry>0x8</entry>
	<entry>Useless, included for compatibility only.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaSC</entry>
	<entry>0xa</entry>
	<entry>Nonzero if board is system controller.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaSRE</entry>
	<entry>0xb</entry>
	<entry>Nonzero if board is asserting REN line.  See
	<link LINKEND="reference-function-ibsre">ibsre()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaEOSrd</entry>
	<entry>0xc</entry>
	<entry>Nonzero if termination of reads on reception of the end-of-string
	character is enabled.  See <link LINKEND="reference-function-ibeos">ibeos()</link>,
	in particular the REOS bit.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaEOSwrt</entry>
	<entry>0xd</entry>
	<entry>Nonzero if EOI is asserted whenever end-of-string character is
	sent.  See <link LINKEND="reference-function-ibeos">ibeos()</link>,
	in particular the XEOS bit.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaEOScmp</entry>
	<entry>0xe</entry>
	<entry>Nonzero if all 8 bits are used to match end-of-string
	character.  Zero if only least significant 7 bits are used.
	See <link LINKEND="reference-function-ibeos">ibeos()</link>,
	in particular the BIN bit.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaEOSchar</entry>
	<entry>0xf</entry>
	<entry>The end-of-string byte.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaPP2</entry>
	<entry>0x10</entry>
	<entry>Nonzero if in local parallel poll configure mode.  Zero
	if in remote parallel poll configure mode.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaTiming</entry>
	<entry>0x11</entry>
	<entry>Number indicating T1 delay.  1 for 2 microseconds, 2 for 500
	nanoseconds, 3 for 350 nanoseconds.  The values are declared in
	the header files as the constants T1_DELAY_2000ns, T1_DELAY_500ns,
	and T1_DELAY_350ns.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaReadAdjust</entry>
	<entry>0x13</entry>
	<entry>Nonzero if byte pairs are automatically swapped during
	reads.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaWriteAdjust</entry>
	<entry>0x14</entry>
	<entry>Nonzero if byte pairs are automatically swapped during
	writes.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaEventQueue</entry>
	<entry>0x15</entry>
	<entry>Nonzero if event queue is enabled.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaSPollBit</entry>
	<entry>0x16</entry>
	<entry>Nonzero if the use of the SPOLL bit in ibsta is enabled.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaSendLLO</entry>
	<entry>0x17</entry>
	<entry>Nonzero if devices connected to this board are automatically
	put into local lockout
	mode when brought online with ibfind() or ibdev().</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaSPollTime</entry>
	<entry>0x18</entry>
	<entry>Timeout for serial polls.  The value of the result
	is between 0 and 17, and has the same meaning as in
	<link LINKEND="reference-function-ibtmo">ibtmo()</link>.
	</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>IbaPPollTime</entry>
	<entry>0x18</entry>
	<entry>Timeout for parallel polls.  The value of the result
	is between 0 and 17, and has the same meaning as in
	<link LINKEND="reference-function-ibtmo">ibtmo()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaEndBitIsNormal</entry>
	<entry>0x1a</entry>
	<entry>Nonzero if END bit of ibsta is set on reception of end-of-string
	character or EOI.  Zero if END bit is only set on EOI.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbaUnAddr</entry>
	<entry>0x1b</entry>
	<entry>Nonzero if UNT (untalk) and UNL (unlisten) commands are automatically
	sent after a completed io operation using this descriptor.</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>IbaHSCableLength</entry>
	<entry>0x1f</entry>
	<entry>Useless, included only for compatibility.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaIst</entry>
	<entry>0x20</entry>
	<entry>Individual status bit, a.k.a. 'ist'.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaRsv</entry>
	<entry>0x21</entry>
	<entry>The current status byte this board will use to respond to
	serial polls.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbaBNA</entry>
	<entry>0x200</entry>
	<entry>Board index (minor number) of interface board which is
	the controller-in-charge of this device's GPIB bus.</entry>
	<entry>device</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibbna">
<refmeta>
	<refentrytitle>ibbna</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibbna</refname>
	<refpurpose>change access board (device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibbna</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>const char *<parameter>name</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibbna() changes the GPIB interface board used to access the device
	specified by <parameter>ud</parameter>.  Subsequent device level
	calls using the descriptor <parameter>ud</parameter> will assume
	the device is connected to the interface board specified by
	<parameter>name</parameter>.  	If you wish to specify a
	device's new access board by board index instead
	of name, you can use the IbcBNA option of ibconfig().
	</para>
	<para>
	The name of a board can be specified
	in the configuration file <link LINKEND="configuration">gpib.conf</link>.
	</para>
	<para>
	On success, iberr is set to the board index of the device's old access board.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibcac">
<refmeta>
	<refentrytitle>ibcac</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibcac</refname>
	<refpurpose>assert ATN (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibcac</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>synchronous</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibcac() causes the board specified by the board descriptor <parameter>ud</parameter>
	to become active controller by asserting the ATN line.
	The board must be controller-in-change in order to assert ATN.
	If <parameter>synchronous</parameter> is nonzero, then
	the board will wait for a data
	byte on the bus to complete its transfer before asserting ATN.
	If the synchronous attempt times out, or <parameter>synchronous</parameter>
	is zero, then ATN will be asserted immediately.
	</para>
	<para>
	It is generally not necessary to call ibcac().  It is provided
	for advanced users who want direct, low-level access to the GPIB bus.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibclr">
<refmeta>
	<refentrytitle>ibclr</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibclr</refname>
	<refpurpose>clear device (device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibclr</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibclr() sends the clear command to the device specified by <parameter>ud</parameter>.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibcmd">
<refmeta>
	<refentrytitle>ibcmd</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibcmd</refname>
	<refpurpose>write command bytes (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibcmd</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>const void *<parameter>commands</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibcmd() writes the <link LINKEND="reference-command-bytes">command bytes</link>
	contained
	in the array <parameter>commands</parameter>
	to the bus.  The number of bytes written from the array is specified by
	<parameter>num_bytes</parameter>.  The <parameter>ud</parameter> argument is a
	board descriptor, and the
	board must be controller-in-charge.  Most of the
	possible command bytes are declared as constants in the header files.
	In particular, the constants GTL, SDC, PPC, GET, TCT, LLO, DCL, PPU, SPE, SPD,
	UNL, UNT,and PPD are available.  Additionally, the inline functions
	MTA(), MLA(), MSA(), and PPE_byte() are available for producing
	'my talk address', 'my listen address', 'my secondary address', and
	'parallel poll enable' command bytes respectively.
	</para>
	<para>
	It is generally not necessary to call ibcmd().  It is provided
	for advanced users who want direct, low-level access to the GPIB bus.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibconfig">
<refmeta>
	<refentrytitle>ibconfig</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibconfig</refname>
	<refpurpose>change configuration (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibconfig</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>option</parameter></paramdef>
		<paramdef>int <parameter>setting</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	Changes various configuration settings associated with the
	board or device descriptor <parameter>ud</parameter>.  The
	<parameter>option</parameter> argument specifies the particular
	setting you wish to modify.  The <parameter>setting</parameter>
	argument specifies the option's new configuration.
	To query the descriptor's configuration, see
	<link LINKEND="reference-function-ibask">ibask()</link>.
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>ibconfig options</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>option</entry>
	<entry>value (hexadecimal)</entry>
	<entry>effect</entry>
	<entry>used for board/device</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>IbcPAD</entry>
	<entry>0x1</entry>
	<entry>Sets GPIB primary address.  Same as
	<link LINKEND="reference-function-ibpad">ibpad()</link>
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcSAD</entry>
	<entry>0x2</entry>
	<entry>Sets GPIB secondary address.  Same as
	<link LINKEND="reference-function-ibsad">ibsad()</link>
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcTMO</entry>
	<entry>0x3</entry>
	<entry>Sets timeout for io operations.  Same as
	<link LINKEND="reference-function-ibtmo">ibmto()</link>.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcEOT</entry>
	<entry>0x4</entry>
	<entry>If setting is nonzero, EOI is asserted with last byte on writes.
	Same as <link LINKEND="reference-function-ibeot">ibeot()</link>.
	</entry>
	<entry></entry>
	</row>
	<row>
	<entry>IbcPPC</entry>
	<entry>0x5</entry>
	<entry>Sets parallel poll configuration.  Same as
	<link LINKEND="reference-function-ibppc">ibppc()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcREADDR</entry>
	<entry>0x6</entry>
	<entry>Useless, included for compatibility only.</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>IbcAUTOPOLL</entry>
	<entry>0x7</entry>
	<entry>If setting is nonzero then automatic serial polling is enabled.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcCICPROT</entry>
	<entry>0x8</entry>
	<entry>Useless, included for compatibility only.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcSC</entry>
	<entry>0xa</entry>
	<entry>If setting is nonzero, board becomes system controller.
	Same as <link LINKEND="reference-function-ibrsc">ibrsc()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcSRE</entry>
	<entry>0xb</entry>
	<entry>If setting is nonzero then board asserts REN line.  Otherwise
	REN is unasserted.  Same as
	<link LINKEND="reference-function-ibsre">ibsre()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcEOSrd</entry>
	<entry>0xc</entry>
	<entry>If setting is nonzero then reads are terminated on reception
	of the end-of-string character.
	See <link LINKEND="reference-function-ibeos">ibeos()</link>,
	in particular the REOS bit.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcEOSwrt</entry>
	<entry>0xd</entry>
	<entry>If setting is nonzero then EOI is asserted whenever
	the end-of-string character is
	sent.  See <link LINKEND="reference-function-ibeos">ibeos()</link>,
	in particular the XEOS bit.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcEOScmp</entry>
	<entry>0xe</entry>
	<entry>If setting is nonzero then all 8 bits are used to match
	the end-of-string
	character.  Otherwise only the least significant 7 bits are used.
	See <link LINKEND="reference-function-ibeos">ibeos()</link>,
	in particular the BIN bit.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcEOSchar</entry>
	<entry>0xf</entry>
	<entry>Sets the end-of-string byte.
	See <link LINKEND="reference-function-ibeos">ibeos()</link>.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcPP2</entry>
	<entry>0x10</entry>
	<entry>If setting is nonzero then the board is put into
	local parallel poll configure mode, and will not change
	its parallel poll configuration in response to receiving
	'parallel poll enable' command bytes from the controller-in-charge.
	Otherwise the board is put in remote parallel poll configure mode.
	Some older hardware does not support local parallel poll
	configure mode.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcTiming</entry>
	<entry>0x11</entry>
	<entry>Sets the T1 delay.  Use setting of 1 for 2 microseconds, 2 for 500
	nanoseconds, or 3 for 350 nanoseconds.  These values are declared in
	the header files as the constants T1_DELAY_2000ns, T1_DELAY_500ns,
	and T1_DELAY_350ns.  A 2 microsecond T1 delay is safest, but
	will limit maximum transfer speeds to a few hundred kilobytes
	per second.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcReadAdjust</entry>
	<entry>0x13</entry>
	<entry>If setting is nonzero then byte pairs are automatically swapped
	during reads.  Presently, this feature is unimplemented.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcWriteAdjust</entry>
	<entry>0x14</entry>
	<entry>If setting is nonzero then byte pairs are automatically swapped
	during writes.  Presently, this feature is unimplemented.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcEventQueue</entry>
	<entry>0x15</entry>
	<entry>If setting is nonzero then the event queue is enabled.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcSPollBit</entry>
	<entry>0x16</entry>
	<entry>If the setting is nonzero then the use of the SPOLL bit in ibsta is enabled.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcSendLLO</entry>
	<entry>0x17</entry>
	<entry>If the setting is nonzero then devices connected to this board are automatically
	put into local lockout
	mode when brought online with ibfind() or ibdev().</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcSPollTime</entry>
	<entry>0x18</entry>
	<entry>Sets timeout for serial polls.  The setting must be
	between 0 and 17, which correspond to the same time periods as in
	<link LINKEND="reference-function-ibtmo">ibtmo()</link>.
	</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>IbcPPollTime</entry>
	<entry>0x18</entry>
	<entry>Sets timeout for parallel polls.  The setting must be
	between 0 and 17, which correspond to the same time periods as in
	<link LINKEND="reference-function-ibtmo">ibtmo()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcEndBitIsNormal</entry>
	<entry>0x1a</entry>
	<entry>If setting is nonzero then the END bit of ibsta is set on
	reception of the end-of-string character or EOI (default).  Otherwise
	END bit is only set on EOI.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>IbcUnAddr</entry>
	<entry>0x1b</entry>
	<entry>If setting is nonzero then UNT (untalk) and UNL (unlisten) commands
	are automatically sent after a completed io operation using this descriptor.
	This option is off by default.</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>IbcHSCableLength</entry>
	<entry>0x1f</entry>
	<entry>Useless, included only for compatibility.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcIst</entry>
	<entry>0x20</entry>
	<entry>Sets the individual status bit, a.k.a. 'ist'.  Same
	as <link LINKEND="reference-function-ibist">ibist()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcRsv</entry>
	<entry>0x21</entry>
	<entry>Sets the current status byte this board will use to respond to
	serial polls.  Same as <link LINKEND="reference-function-ibrsv">ibrsv()</link>.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>IbcBNA</entry>
	<entry>0x200</entry>
	<entry>Changes the GPIB interface board used to access a device.  The
	setting specifies the board index of the new access board.  This configuration
	option is similar to <link LINKEND="reference-function-ibbna">ibbna()</link>
	except the new board is specified by its board index instead of a name.
	</entry>
	<entry>device</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibdev">
<refmeta>
	<refentrytitle>ibdev</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibdev</refname>
	<refpurpose>open a device (device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibdev</function></funcdef>
		<paramdef>int <parameter>board_index</parameter></paramdef>
		<paramdef>int <parameter>pad</parameter></paramdef>
		<paramdef>int <parameter>sad</parameter></paramdef>
		<paramdef>int <parameter>timeout</parameter></paramdef>
		<paramdef>int <parameter>send_eoi</parameter></paramdef>
		<paramdef>int <parameter>eos</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibdev() is used to obtain a device descriptor, which can then be used by
	other functions in the library.  The argument <parameter>board_index</parameter>
	specifies which GPIB interface board the device is connected to.
	The <parameter>pad</parameter> and <parameter>sad</parameter> arguments specify
	the GPIB address of the device to be opened (see <link LINKEND="reference-function-ibpad">
	ibpad()</link> and <link LINKEND="reference-function-ibsad">ibsad()</link>).
	The timeout for io operations is specified by <parameter> timeout </parameter>
	(see <link LINKEND="reference-function-ibtmo">ibtmo()</link>). If
	<parameter>send_eoi</parameter> is nonzero, then the EOI
	line will be asserted with the last byte sent during writes (see
	<link LINKEND="reference-function-ibeot">ibeot()</link>).
	Finally, the <parameter>eos</parameter>
	argument specifies the end-of-string character and whether or not its
	reception should terminate reads (see <link LINKEND="reference-function-ibeos">
	ibeos()</link>).
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	If sucessful, returns a (non-negative) device descriptor.  On failure, -1 is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibeos">
<refmeta>
	<refentrytitle>ibeos</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibeos</refname>
	<refpurpose>set end-of-string mode (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibeos</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>eosmode</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibeos() is used to set the end-of-string character and mode.  The least
	significant 8 bits of <parameter>eosmode</parameter> specify the
	eos character.  You may also bitwise-or one or more of the following
	bits to set the eos mode:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>End-of-String Mode Bits</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value (hexadecimal)</entry>
	<entry>meaning</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>REOS</entry>
	<entry>0x400</entry>
	<entry>Enable termination of reads when eos character is received.</entry>
	</row>
	<row>
	<entry>XEOS</entry>
	<entry>0x800</entry>
	<entry>Assert the EOI line whenever the eos character is sent during writes.</entry>
	</row>
	<row>
	<entry>BIN</entry>
	<entry>0x1000</entry>
	<entry>Match eos character using all 8 bits (instead of only looking at
	the 7 least significant bits).</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibeot">
<refmeta>
	<refentrytitle>ibeot</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibeot</refname>
	<refpurpose>assert EOI with last data byte (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibeot</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>send_eoi</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If <parameter>send_eoi</parameter> is non-zero, then the EOI
	line will be asserted with the last byte sent by
	calls to <link LINKEND="reference-function-ibwrt">ibwrt()</link>
	and related functions.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibevent">
<refmeta>
	<refentrytitle>ibevent</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibevent</refname>
	<refpurpose>get events from event queue (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibevent</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>short *<parameter>event</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibevent() is used to obtain the oldest event stored in the event
	queue of the board specified by the board descriptor
	<parameter>ud</parameter>.  The EVENT bit of
	<link LINKEND="reference-globals-ibsta">ibsta</link> indicates
	that the event queue contains 1 or more events.
	An event may be a clear command, a trigger command, or reception
	of an interface clear.  The type of event is stored in the location
	specified by <parameter>event</parameter> and may be set to any of the
	following values:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="0">
	<title>events</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value</entry>
	<entry>description</entry>
	<tbody>
	<row>
	<entry>EventNone</entry>
	<entry>0</entry>
	<entry>The board's event queue is empty</entry>
	</row>
	<row>
	<entry>EventDevTrg</entry>
	<entry>1</entry>
	<entry>The board has received a trigger command from the controller-in-charge.</entry>
	</row>
	<row>
	<entry>EventDevClr</entry>
	<entry>2</entry>
	<entry>The board has received a clear command from the controller-in-charge.</entry>
	</row>
	<row>
	<entry>EventIFC</entry>
	<entry>3</entry>
	<entry>The board has received an interface clear from the system controller.
	Note, some models of GPIB interface board lack the ability to report interface
	clear events.</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
	<para>
	Each interface board has a single event queue which is shared across
	all processes and threads. So, only one process can retrieve any given event
	from the queue.  Also, the queue is of finite size so events may be lost
	(ibevent() will return an error) if it is neglected too long.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibfind">
<refmeta>
	<refentrytitle>ibfind</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibfind</refname>
	<refpurpose>open a board or device (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibfind</function></funcdef>
		<paramdef>const char *<parameter>name</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibfind() returns a board or device descriptor based on the information
	found in the <link LINKEND="configuration">configuration file</link>.
	It is not required to use this function, since device descriptors
	can be obtained with <link LINKEND="reference-function-ibdev">ibdev()</link>
	and the 'board index' (minor number in the configuration file)
	can be used directly as a board descriptor.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	If sucessful, returns a (non-negative) board or device descriptor.
	On failure, -1 is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibgts">
<refmeta>
	<refentrytitle>ibgts</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibgts</refname>
	<refpurpose>release ATN (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibgts</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>shadow_handshake</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibgts() is the complement of <link LINKEND="reference-function-ibcac">ibcac()</link>,
	and causes the board specified by the board descriptor <parameter>ud</parameter>
	to go to standby by releasing the ATN line.
	The board must be controller-in-change to change the state of the ATN line.
	If <parameter>shadow_handshake</parameter> is nonzero, then
	the board will handshake any data
	bytes it receives until it encounters an EOI or end-of-string character,
	or the ATN line is asserted again.  The received data is discarded.
	</para>
	<para>
	It is generally not necessary to call ibgts().  It is provided
	for advanced users who want direct, low-level access to the GPIB bus.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibist">
<refmeta>
	<refentrytitle>ibist</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibist</refname>
	<refpurpose>set individual status bit (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibist</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>ist</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If <parameter>ist</parameter> is nonzero, then the individual status bit
	of the board specified by the board descriptor <parameter>ud</parameter>
	is set.  If <parameter>ist</parameter> is zero then the individual status
	bit is cleared.  The individual status bit is sent by the board in response
	to parallel polls.
	</para>
	<para>
	On success, <link LINKEND="reference-globals-iberr">iberr</link> is set
	to the previous ist value.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-iblines">
<refmeta>
	<refentrytitle>iblines</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>iblines</refname>
	<refpurpose>monitor bus lines (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>iblines</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>short *<parameter>line_status</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	iblines() is used to obtain the status of the control and
	handshaking <link LINKEND="gpib-protocol-bus-lines">bus lines</link> of the
	bus.  The board used to monitor the bus
	is specified by the <parameter>ud</parameter> argument,
	and the status of the various bus lines are written to
	the location specified by <parameter>line_status</parameter>.
	</para>
	<para>
	Some older chips are not capable of reporting the status
	of the bus lines, so each line has two corresponding bits in
	<parameter>line_status</parameter>.  One bit indicates if
	the board can monitor the line, and the other bit indicates
	the line's state.
	The meaning of the <parameter>line_status</parameter> bits are
	as follows:
	</para>
		<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="0">
	<title>line status bits</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value</entry>
	<entry>description</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>ValidDAV</entry>
	<entry>0x1</entry>
	<entry>The BusDAV bit is valid.</entry>
	</row>
	<row>
	<entry>ValidNDAC</entry>
	<entry>0x2</entry>
	<entry>The BusNDAC bit is valid.</entry>
	</row>
	<row>
	<entry>ValidNRFD</entry>
	<entry>0x4</entry>
	<entry>The BusNRFD bit is valid.</entry>
	</row>
	<row>
	<entry>ValidIFC</entry>
	<entry>0x8</entry>
	<entry>The BusIFC bit is valid.</entry>
	</row>
	<row>
	<entry>ValidREN</entry>
	<entry>0x10</entry>
	<entry>The BusREN bit is valid.</entry>
	</row>
	<row>
	<entry>ValidSRQ</entry>
	<entry>0x20</entry>
	<entry>The BusSRQ bit is valid.</entry>
	</row>
	<row>
	<entry>ValidATN</entry>
	<entry>0x40</entry>
	<entry>The BusATN bit is valid.</entry>
	</row>
	<row>
	<entry>ValidEOI</entry>
	<entry>0x80</entry>
	<entry>The BusEOI bit is valid.</entry>
	</row>
	<row>
	<entry>BusDAV</entry>
	<entry>0x100</entry>
	<entry>Set/cleared if the DAV line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusNDAC</entry>
	<entry>0x200</entry>
	<entry>Set/cleared if the NDAC line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusNRFD</entry>
	<entry>0x400</entry>
	<entry>Set/cleared if the NRFD line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusIFC</entry>
	<entry>0x800</entry>
	<entry>Set/cleared if the IFC line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusREN</entry>
	<entry>0x1000</entry>
	<entry>Set/cleared if the REN line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusSRQ</entry>
	<entry>0x2000</entry>
	<entry>Set/cleared if the SRQ line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusATN</entry>
	<entry>0x4000</entry>
	<entry>Set/cleared if the ATN line is asserted/unasserted.</entry>
	</row>
	<row>
	<entry>BusEOI</entry>
	<entry>0x8000</entry>
	<entry>Set/cleared if the EOI line is asserted/unasserted.</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	<para>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibloc">
<refmeta>
	<refentrytitle>ibloc</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibloc</refname>
	<refpurpose>go to local mode (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibloc</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	Causes the board or device specified by the descriptor <parameter>ud</parameter>
	to go to local mode.  If <parameter>ud</parameter> is a board descriptor,
	and the board is in local lockout, then the function will fail.
	</para>
	<para>
	Note, if the system controller is asserting the REN line, then devices on
	the bus will
	return to remote mode the next time they are addressed by the controller
	in charge.
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibonl">
<refmeta>
	<refentrytitle>ibonl</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibonl</refname>
	<refpurpose>close or reinitialize descriptor (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibonl</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>online</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If the <parameter>online</parameter> is zero, then ibonl() frees the
	resources associated with the board or device descriptor
	<parameter>ud</parameter>.  The descriptor cannot be used again after the
	ibonl() call.
	</para>
	<para>
	If the <parameter>online</parameter> is nonzero, then all the settings
	associated with the descriptor (GPIB address, end-of-string mode, timeout,
	etc.) are reset to their 'default' values.  The 'default' values are
	the settings the descriptor had when it was first obtained with
	<link LINKEND="reference-function-ibdev">ibdev()</link> or
	<link LINKEND="reference-function-ibfind">ibfind()</link>.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibpad">
<refmeta>
	<refentrytitle>ibpad</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibpad</refname>
	<refpurpose>set primary GPIB address (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibpad</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>pad</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibpad() sets the GPIB primary address to <parameter>pad</parameter>
	for the device or board specified by the descriptor <parameter>ud</parameter>.
	If <parameter>ud</parameter> is a device descriptor, then the setting is
	local to the descriptor (it does not affect the behaviour of calls using
	other descriptors, even if they refer to the same physical device).  If
	<parameter>ud</parameter> is a board descriptor, then the board's
	primary address is changed immediately, which is a global change affecting
	anything (even other processes) using the board.  Valid GPIB primary
	addresses are in the range from 0 to 30.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibpct">
<refmeta>
	<refentrytitle>ibpct</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibpct</refname>
	<refpurpose>pass control (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibpct</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibpct() passes control to the device specified by the device
	descriptor <parameter>ud</parameter>.  The device becomes
	the new controller-in-charge.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibppc">
<refmeta>
	<refentrytitle>ibppc</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibppc</refname>
	<refpurpose>parallel poll configure (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibppc</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>configuration</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	Configures the parallel poll response of the device or board specified
	by <parameter>ud</parameter>.  The <parameter>configuration</parameter>
	should either be set to the 'PPD' constant to disable parallel poll
	responses, or set to the return value of the
	<link LINKEND="reference-function-ppe-byte">PPE_byte()</link> inline
	function to enable and
	configure the parallel poll response.
	</para>
	<para>
	After configuring the parallel poll response of devices on a bus,
	you may use
	<link LINKEND="reference-function-ibrpp">ibrpp()</link> to
	parallel poll the devices.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrd">
<refmeta>
	<refentrytitle>ibrd</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrd</refname>
	<refpurpose>read data bytes (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrd</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>void *<parameter>buffer</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibrd() is used to read data bytes from a device or board.  The argument
	<parameter>ud</parameter> can be either a device or board descriptor.
  Up to
	<parameter>num_bytes</parameter> bytes
	are read into the user-supplied array <parameter>buffer</parameter>.
	The read may be terminated by a
	timeout occuring(see <link LINKEND="reference-function-ibtmo">ibtmo()</link>),
	the talker asserting the EOI line, the board receiving the
	end-of-string character (see
	<link LINKEND="reference-function-ibeos">ibeos()</link>), receiving a device
	clear command, or receiving an interface clear.
	</para>
	<para>
	If <parameter>ud</parameter> is a device descriptor, then the library
	automatically handles addressing the device as talker and the interface
	board as listener before performing the read.
	</para>
	<para>
	If <parameter>ud</parameter> is a board descriptor, no addressing
	is performed and the board must be addressed as a listener
	by the controller-in-charge.
	</para>
	<para>
	After the ibrd() call, ibcnt and ibcntl are set to the number of bytes
	read.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrdf">
<refmeta>
	<refentrytitle>ibrdf</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrdf</refname>
	<refpurpose>read data bytes to file (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrdf</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>const char *<parameter>file_path</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibrdf() is similar to <link LINKEND="reference-function-ibwrt">ibrd()</link>
	except that the data bytes read are stored in a file instead
	of an array in memory.  <parameter>file_path</parameter> specifies
	the save file.  If the file already exists, the data will be appended
	onto the end of the file.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrpp">
<refmeta>
	<refentrytitle>ibrpp</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrpp</refname>
	<refpurpose>perform a parallel poll (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrpp</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>char *<parameter>ppoll_result</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibrpp() causes the interface board to perform a parallel poll, and stores
	the resulting byte in the
	location specified by <parameter>ppoll_result</parameter>.  The devices
	on the bus you wish to poll should be configured beforehand with
	<link LINKEND="reference-function-ibppc">ibppc()</link>.  The board
	which performs the parallel poll must be controller-in-charge, and
	is specified by the descriptor <parameter>ud</parameter>.
	If <parameter>ud</parameter> is a device descriptor instead of
	a board descriptor, the device's access board performs the
	parallel poll.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrsc">
<refmeta>
	<refentrytitle>ibrsc</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrsc</refname>
	<refpurpose>request system control (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrsc</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>request_control</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If <parameter>request_control</parameter> is nonzero, then the board
	specified by the board descriptor <parameter>ud</parameter> is
	made system controller.  If <parameter>request_control</parameter>
	is zero, then the board releases system control.
	</para>
	<para>
	The system controller has the ability
	to assert the REN and IFC lines, and is typically also the
	controller-in-charge.  A GPIB bus may not have more than one
	system controller.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrsp">
<refmeta>
	<refentrytitle>ibrsp</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrsp</refname>
	<refpurpose>conduct serial poll (device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrsp</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>char *<parameter>result</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibrsp() serial polls the device specified by <parameter>ud</parameter>.
	The status byte is stored in the location specified by <parameter>result</parameter>.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrsv">
<refmeta>
	<refentrytitle>ibrsv</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrsv</refname>
	<refpurpose>request service (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrsv</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>status_byte</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	The serial poll response byte of the board specified by the board
	descriptor <parameter>ud</parameter> is set to <parameter>status_byte</parameter>.
	If the request service bit (0x40 hexadecimal) in <parameter>status_byte</parameter>
	is set, then the board will also request service by asserting the RQS line.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibsad">
<refmeta>
	<refentrytitle>ibsad</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsad</refname>
	<refpurpose>set secondary GPIB address (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibsad</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>sad</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibsad() sets the GPIB secondary address
	of the device or board specified by the descriptor <parameter>ud</parameter>.
	If <parameter>ud</parameter> is a device descriptor, then the setting is
	local to the descriptor (it does not affect the behaviour of calls using
	other descriptors, even if they refer to the same physical device).  If
	<parameter>ud</parameter> is a board descriptor, then the board's
	secondary address is changed immediately, which is a global change affecting
	anything (even other processes) using the board.
	</para>
	<para>
	This library follows NI's unfortunate convention of adding 0x60 hexadecimal (96
	decimal) to
	secondary addresses.  That is, if you wish to set the secondary address
	to 3, you should set <parameter>sad</parameter> to 0x63.  Setting
	<parameter>sad</parameter> to 0 disables the use of secondary addressing.
	Valid GPIB secondary addresses are in the range from 0 to 30 (which correspond
	to <parameter>sad</parameter> values of 0x60 to 0x7e).
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibsic">
<refmeta>
	<refentrytitle>ibsic</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsic</refname>
	<refpurpose>interface clear (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibsic</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibsre">
<refmeta>
	<refentrytitle>ibsre</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsre</refname>
	<refpurpose>set remote enable (board)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibsre</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>enable</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If <parameter>enable</parameter> is nonzero, then the board specified
	by the board descriptor <parameter>ud</parameter> asserts the REN line.
	If <parameter>enable</parameter> is zero, the REN line is unasserted.
	The board must be the system controller.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibtmo">
<refmeta>
	<refentrytitle>ibtmo</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibtmo</refname>
	<refpurpose>adjust io timeout (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibtmo</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>timeout</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibtmo() sets timeout for IO operations performed using the board
	or device descriptor
	<parameter>ud</parameter>.  The actual amount of time before
	a timeout occurs may be greater than the period specified, but
	never less.
	<parameter>timeout</parameter> is specified by using one of
	the following constants:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="0">
	<title>Timeout constants</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value</entry>
	<entry>timeout</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>TNONE</entry>
	<entry>0</entry>
	<entry>Never timeout.</entry>
	</row>
	<row>
	<entry>T10us</entry>
	<entry>1</entry>
	<entry>10 microseconds</entry>
	</row>
	<row>
	<entry>T30us</entry>
	<entry>2</entry>
	<entry>30 microseconds</entry>
	</row>
	<row>
	<entry>T100us</entry>
	<entry>3</entry>
	<entry>100 microseconds</entry>
	</row>
	<row>
	<entry>T300us</entry>
	<entry>4</entry>
	<entry>300 microseconds</entry>
	</row>
	<row>
	<entry>T1ms</entry>
	<entry>5</entry>
	<entry>1 millisecond</entry>
	</row>
	<row>
	<entry>T3ms</entry>
	<entry>6</entry>
	<entry>3 milliseconds</entry>
	</row>
	<row>
	<entry>T10ms</entry>
	<entry>7</entry>
	<entry>10 milliseconds</entry>
	</row>
	<row>
	<entry>T30ms</entry>
	<entry>8</entry>
	<entry>30 milliseconds</entry>
	</row>
	<row>
	<entry>T100ms</entry>
	<entry>9</entry>
	<entry>100 milliseconds</entry>
	</row>
	<row>
	<entry>T300ms</entry>
	<entry>10</entry>
	<entry>300 milliseconds</entry>
	</row>
	<row>
	<entry>T1s</entry>
	<entry>11</entry>
	<entry>1 second</entry>
	</row>
	<row>
	<entry>T3s</entry>
	<entry>12</entry>
	<entry>3 seconds</entry>
	</row>
	<row>
	<entry>T10s</entry>
	<entry>13</entry>
	<entry>10 seconds</entry>
	</row>
	<row>
	<entry>T30s</entry>
	<entry>14</entry>
	<entry>30 seconds</entry>
	</row>
	<row>
	<entry>T100s</entry>
	<entry>15</entry>
	<entry>100 seconds</entry>
	</row>
	<row>
	<entry>T300s</entry>
	<entry>16</entry>
	<entry>300 seconds</entry>
	</row>
	<row>
	<entry>T1000s</entry>
	<entry>17</entry>
	<entry>1000 seconds</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibwrt">
<refmeta>
	<refentrytitle>ibwrt</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibwrt</refname>
	<refpurpose>write data bytes (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibwrt</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>const void *<parameter>data</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibwrt() is used to write data bytes to a device or board.  The argument
	<parameter>ud</parameter> can be either a device or board descriptor.
	<parameter>num_bytes</parameter> specifies how many bytes
	are written from the user-supplied array <parameter>data</parameter>.
	EOI may be asserted with the last byte sent or when the end-of-string
	character is sent (see <link LINKEND="reference-function-ibeos">
	ibeos()</link> and <link LINKEND="reference-function-ibeot">
	ibeot()</link>).  The write operation
	may be interrupted by a timeout (see <link LINKEND="reference-function-ibtmo">
	ibtmo()</link>), the board receiving a device clear command, or
	receiving an interface clear.
	</para>
	<para>
	If <parameter>ud</parameter> is a device descriptor, then the library
	automatically handles addressing the device as listener and the interface
	board as talker, before sending the data bytes onto the bus.
	</para>
	<para>
	If <parameter>ud</parameter>
	is a board descriptor, the board simply writes the data onto the bus.  The
	controller-in-charge must address the board as talker.
	</para>
	<para>
	After the ibwrt() call, ibcnt and ibcntl are set to the number of bytes
	written.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibwrtf">
<refmeta>
	<refentrytitle>ibwrtf</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibwrtf</refname>
	<refpurpose>write data bytes from file (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibwrtf</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>const char *<parameter>file_path</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibwrtf() is similar to <link LINKEND="reference-function-ibwrt">ibwrt()</link>
	except that the data to be written is taken from a file instead
	of an array in memory.  <parameter>file_path</parameter> specifies
	the file, which is written byte for byte onto the bus.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

</section>

<section>
<title>
	'Multidevice API' Functions
</title>

<refentry ID="reference-function-allspoll">
<refmeta>
	<refentrytitle>AllSPoll</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>AllSPoll</refname>
	<refpurpose>Serial poll multiple devices</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>void <function>AllSPoll</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>Addr4882_t *<parameter>addressList</parameter></paramdef>
		<paramdef>short *<parameter>resultList</parameter></paramdef>
	</funcprototype>
	<funcprototype>
		<funcdef>void <function>AllSpoll</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>const Addr4882_t *<parameter>addressList</parameter></paramdef>
		<paramdef>short *<parameter>resultList</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	AllSPoll() causes the interface board specified by <parameter>board_desc</parameter>
	to serial poll all the GPIB addresses specified in the <parameter>addressList</parameter>
	array.  The results of the serial polls are stored into <parameter>resultList</parameter>.
	If you only wish to serial poll a single device,
	<link LINKEND="reference-function-readstatusbyte">ReadStatusByte()</link> or
	<link LINKEND="reference-function-ibrsp">ibrsp()</link> may be
	more convenient.
	</para>
	<para>
	This function may also be invoked with the alternate capitalization 'AllSpoll'
	for compatibility with NI's library.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-devclear">
<refmeta>
	<refentrytitle>DevClear</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>DevClear</refname>
	<refpurpose>Clear a device</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>void <function>DevClear</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>Addr4882_t <parameter>address</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	DevClear() causes the interface board specified by <parameter>board_desc</parameter>
	to send the clear command to the GPIB addresses specified by <parameter>address</parameter>.  The results of the serial polls are stored into <parameter>resultList</parameter>.
	If you wish to clear multiple devices simultaneously, use
	<link LINKEND="reference-function-devclearlist">DevClearList()</link>
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-devclearlist">
<refmeta>
	<refentrytitle>DevClearList</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>DevClearList</refname>
	<refpurpose>Clear multiple devices</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>void <function>DevClearList</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>const Addr4882_t *<parameter>addressList</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	DevClear() causes the interface board specified by <parameter>board_desc</parameter>
	to send the clear command simultaneously to all the GPIB addresses specified by the
	<parameter>addressList</parameter> array.  The results of the serial polls are stored into <parameter>resultList</parameter>.
	If you only wish to clear a single device,
	<link LINKEND="reference-function-devclear">DevClear()</link>
	or <link LINKEND="reference-function-ibclr">ibclr()</link> may
	be more convenient.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-enablelocal">
<refmeta>
	<refentrytitle>EnableLocal</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>EnableLocal</refname>
	<refpurpose>Put devices into local mode.</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>void <function>EnableLocal</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>const Addr4882_t *<parameter>addressList</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	EnableLocal() addresses
	all of the devices in the <parameter>addressList</parameter> array as listeners
	then sends the GTL (go to local) command byte, causing them to enter local mode.
	This requires that the board is the controller-in-charge.
	Note that while the REN (remote enable) bus line is asserted, the devices
	will return to remote mode the next time they are addressed.
	</para>
	<para>
	If <parameter>addressList</parameter> is empty or NULL, then the REN
	line is unasserted and all devices enter local mode.  The board must
	be system controller to change the state of the REN line.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-enableremote">
<refmeta>
	<refentrytitle>EnableRemote</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>EnableRemote</refname>
	<refpurpose>Put devices into remote mode.</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>void <function>EnableRemote</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>const Addr4882_t *<parameter>addressList</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	EnableRemote() asserts the REN (remote enable) line, and addresses
	all of the devices
	in the <parameter>addressList</parameter> array as listeners (causing
	them to enter remote mode).  The board must be system controller.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-readstatusbyte">
<refmeta>
	<refentrytitle>ReadStatusByte</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ReadStatusByte</refname>
	<refpurpose>Serial poll a device</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>void <function>ReadStatusByte</function></funcdef>
		<paramdef>int <parameter>board_desc</parameter></paramdef>
		<paramdef>Addr4882_t <parameter>address</parameter></paramdef>
		<paramdef>short *<parameter>result</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ReadStatusByte() causes the board specified by
	the board descriptor <parameter>board_desc</parameter> to serial poll
	the GPIB address specified by <parameter>address</parameter>.  The
	status byte is stored at the location specified by the <parameter>result</parameter>
	pointer.  If you wish to serial poll multiple devices, it
	may be slightly more efficient to use
	<link LINKEND="reference-function-allspoll">AllSPoll()</link>.
	Serial polls may also be conducted with the 'traditional API' function
	<link LINKEND="reference-function-ibrsp">ibrsp()</link>.
	</para>
</refsect1>
</refentry>

</section>

<section>
<title>
	Utility Functions
</title>

<refentry ID="reference-function-mla">
<refmeta>
	<refentrytitle>MLA</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>MLA</refname>
	<refpurpose>Generate 'my listen address' command byte</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>uint8_t <function>MLA</function></funcdef>
		<paramdef>unsigned int <parameter>address</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	MLA() returns a 'my listen address'
	<link LINKEND="reference-command-bytes">command byte</link> corresponding
	to the <parameter>address</parameter> argument.  The <parameter>address</parameter>
	my be between 0 and 30.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The appropriate MLA command byte is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-msa">
<refmeta>
	<refentrytitle>MSA</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>MSA</refname>
	<refpurpose>Generate 'my secondary address' command byte</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>uint8_t <function>MSA</function></funcdef>
		<paramdef>unsigned int <parameter>address</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	MSA() returns a 'my secondary address'
	<link LINKEND="reference-command-bytes">command byte</link> corresponding
	to the <parameter>address</parameter> argument.  The <parameter>address</parameter>
	my be between 0 and 30.  This macro is also useful for mangling
	secondary addresses from the 'real' values between 0 and 30 to the
	range 0x60 to 0x7e used by most of the library's functions.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The appropriate MSA command byte is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-mta">
<refmeta>
	<refentrytitle>MTA</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>MTA</refname>
	<refpurpose>Generate 'my talk address' command byte</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>uint8_t <function>MTA</function></funcdef>
		<paramdef>unsigned int <parameter>address</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	MTA() returns a 'my talk address'
	<link LINKEND="reference-command-bytes">command byte</link> corresponding
	to the <parameter>address</parameter> argument.  The <parameter>address</parameter>
	my be between 0 and 30.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The appropriate MTA command byte is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ppe-byte">
<refmeta>
	<refentrytitle>PPE_byte</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>PPE_byte</refname>
	<refpurpose>Generate 'parallel poll enable' command byte</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>uint8_t <function>PPE_byte</function></funcdef>
		<paramdef>unsigned int <parameter>dio_line</parameter></paramdef>
		<paramdef>int <parameter>sense</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	PPE_byte() returns a 'parallel poll enable'
	<link LINKEND="reference-command-bytes">command byte</link> corresponding
	to the <parameter>dio_line</parameter> and <parameter>sense</parameter>
	arguments.  The <parameter>dio_line</parameter> (valid values are 1 through 8)
	specifies which dio line the device being configured should use to send
	back its parallel poll response.  The <parameter>sense</parameter> argument
	specifies the polarity of the response.  If <parameter>sense</parameter>
	is nonzero, then the specified dio line will be asserted to indicate
	that the 'individual status bit' (or 'ist') is 1.  If <parameter>sense</parameter>
	is zero, then the specified dio line will be asserted when ist is zero.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The appropriate PPE command byte is returned.
	</para>
</refsect1>
</refentry>

</section>

</section>

<section ID="gpib-protocol">
<title>GPIB protocol</title>

<section ID="reference-command-bytes">
	<title>GPIB command bytes</title>
	<para>
	The meaning and values of the possible GPIB command bytes
	are as follows:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>GPIB command bytes</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>byte value (hexadecimal)</entry>
	<entry>name</entry>
	<entry>description</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>0x1</entry>
	<entry>GTL</entry>
	<entry>Go to local</entry>
	</row>
	<row>
	<entry>0x4</entry>
	<entry>SDC</entry>
	<entry>Selected device clear</entry>
	</row>
	<row>
	<entry>0x5</entry>
	<entry>PPC</entry>
	<entry>Parallel poll configure</entry>
	</row>
	<row>
	<entry>0x8</entry>
	<entry>GET</entry>
	<entry>Group execute trigger</entry>
	</row>
	<row>
	<entry>0x9</entry>
	<entry>TCT</entry>
	<entry>Take control</entry>
	</row>
	<row>
	<entry>0x11</entry>
	<entry>LLO</entry>
	<entry>Local lockout</entry>
	</row>
	<row>
	<entry>0x14</entry>
	<entry>DCL</entry>
	<entry>Device clear</entry>
	</row>
	<row>
	<entry>0x15</entry>
	<entry>PPU</entry>
	<entry>Parallel poll unconfigure</entry>
	</row>
	<row>
	<entry>0x18</entry>
	<entry>SPE</entry>
	<entry>Serial poll enable</entry>
	</row>
	<row>
	<entry>0x19</entry>
	<entry>SPD</entry>
	<entry>Serial poll disable</entry>
	</row>
	<row>
	<entry>0x20 to 0x3e</entry>
	<entry>MLA0 to MLA30</entry>
	<entry>My (primary) listen address 0 to 30</entry>
	</row>
	<row>
	<entry>0x3f</entry>
	<entry>UNL</entry>
	<entry>Unlisten</entry>
	</row>
	<row>
	<entry>0x40 to 0x5e</entry>
	<entry>MTA0 to MTA30</entry>
	<entry>My (primary) talk address 0 to 30</entry>
	</row>
	<row>
	<entry>0x5f</entry>
	<entry>UNT</entry>
	<entry>Untalk</entry>
	</row>
	<row>
	<entry>0x60 to 0x6f</entry>
	<entry>MSA0 to MSA15, also PPE</entry>
	<entry>When following a talk or listen address, this is
	'my secondary address' 0 to 15.  When following a parallel
	poll configure, this is 'parallel poll enable'.  For
	parallel poll enable, the least significant 3 bits
	of the command byte specify which DIO line the device
	should use to send its parallel poll response.  The
	fourth least significant bit (0x8)
	indicates the 'sense' or polarity the device should use
	when responding.
	</entry>
	</row>
	<row>
	<entry>0x70 to 0x7d</entry>
	<entry>MSA16 to MSA29, also PPD</entry>
	<entry>When following a talk or listen address, this is
	'my secondary address' 16 to 29.  When following a parallel
	poll configure, this is 'parallel poll disable'.</entry>
	</row>
	<row>
	<entry>0x7e</entry>
	<entry>MSA30</entry>
	<entry>My secondary address 30</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</section>

<section ID="gpib-protocol-bus-lines">
<title>GPIB bus lines</title>
<para>
Physically, the GPIB bus consists of 8 data lines, 3 handshaking
lines, and 5 control lines (and 8 ground
lines).  Brief descriptions
of how they are used follow:
</para>
<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>GPIB bus lines</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>bus line</entry>
	<entry>description</entry>
	<entry>pin number</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>DIO1 through DIO8</entry>
	<entry>Data input/output bits.  These 8 lines are used to read and write the 8 bits
	of a data or command byte that is being sent over the bus.</entry>
	<entry>DIO1 to DIO4 use pins 1 to 4, DIO5 to DIO8 use pins 13 to 16</entry>
	</row>
	<row>
	<entry>EOI</entry>
	<entry>End-or-identify.  This line is asserted with the last byte of
	data during a write, to indicate the end of the message.  It can
	also be asserted along with the ATN line to conduct a parallel poll.</entry>
	<entry>5</entry>
	</row>
	<row>
	<entry>DAV</entry>
	<entry>Data valid.  This is a handshaking line, used to signal that
	the value being sent with DIO1-DIO8 is valid.  During transfers the
	DIO1-DIO8 lines are set, then the DAV line is asserted after
	a delay called the 'T1 delay'.  The T1 delay lets the data lines
	settle to stable values before they are read.</entry>
	<entry>6</entry>
	</row>
	<row>
	<entry>NRFD</entry>
	<entry>Not ready for data.  NRFD is a handshaking line asserted by
	listeners to indicate
	they are not ready to receive a new data byte.</entry>
	<entry>7</entry>
	</row>
	<row>
	<entry>NDAC</entry>
	<entry>Not data accepted.  NDAC is a handshaking line asserted by
	listeners to indicate
	they have not yet read the byte contained on the DIO lines.</entry>
	<entry>8</entry>
	</row>
	<row>
	<entry>IFC</entry>
	<entry>Interface clear.  The system controller can assert this line
	(it should be asserted for at least 100 microseconds) to reset
	the bus and make itself controller-in-charge.</entry>
	<entry>9</entry>
	</row>
	<row>
	<entry>SRQ</entry>
	<entry>Service request.  Devices on the bus can assert this line
	to request service from the controller-in-charge.  The controller
	can then poll the devices until it finds the device requesting
	service, and perform whatever action is necessary.</entry>
	<entry>10</entry>
	</row>
	<row>
	<entry>ATN</entry>
	<entry>Attention.  ATN is asserted to indicate that the DIO lines
	contain a <link LINKEND="reference-command-bytes">command byte</link>
	(as opposed to a data byte).  Also, it is asserted with EOI
	when conducting parallel polls.</entry>
	<entry>11</entry>
	</row>
	<row>
	<entry>REN</entry>
	<entry>Remote enable.  Asserted by the system controller, it enables
	devices to enter remote mode.  When REN is asserted, a device will
	enter remote mode when it is addressed by the controller.  When
	REN is false, all devices will immediately return to local mode.
	</entry>
	<entry>17</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
</para>
</section>

</section>

&license

</article>

