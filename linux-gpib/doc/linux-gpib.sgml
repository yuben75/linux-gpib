<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN"
	"docbook/dtd/4.1/docbook.dtd"[
<!ENTITY license SYSTEM "fdl.xml">
]>

<article>

<articleinfo>
<title>
	Linux-GPIB Documentation
</title>

<author>
	<firstname>Frank</firstname>
	<othername>Mori</othername>
	<surname>Hess</surname>
	<affiliation>
	<address>
		fmhess@users.sourceforge.net
	</address>
	</affiliation>
</author>

<copyright>
<year>2003</year>
<holder>Frank Mori Hess</holder>
</copyright>
</articleinfo>

<section>
<title>
	Copying
</title>
<para>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
<link LINKEND="gfdl">"GNU Free Documentation License"</link>.
</para>
</section>

<section ID="reference">
<title>
	Linux-GPIB Reference
</title>
<para>
	Reference for libgpib functions, macros, and constants.
</para>
<section>
<title>Global Variables</title>

<refentry ID="reference-globals-ibcnt">
<refmeta>
	<refentrytitle>ibcnt and ibcntl</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibcnt and ibcntl</refname>
	<refpurpose>hold number of bytes transferred, or errno</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int ibcnt;
volatile long ibcntl;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibcnt and ibcntl are set after IO operations to the the the number of
	bytes sent or received.  They are also set to the value of errno after
	EDVR or EFSO errors.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-globals-iberr">
<refmeta>
	<refentrytitle>iberr</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>iberr</refname>
	<refpurpose>holds error code</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int iberr;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	iberr is set whenever a function from the 'traditional' or 'multidevice'
	API fails with an error.  The meaning of each possible value of iberr
	is summarized
	in the following table:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>iberr error codes</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value</entry>
	<entry>meaning</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>EDVR</entry>
	<entry>0</entry>
	<entry>A system call has failed.  ibcnt/ibcntl will be set to the
	value of errno.</entry>
	</row>
	<row>
	<entry>ECIC</entry>
	<entry>1</entry>
	<entry>Your interface board needs to be controller-in-charge, but
	is not.</entry>
	</row>
	<row>
	<entry>ENOL</entry>
	<entry>2</entry>
	<entry>You have attempted to write data or command bytes, but
	there are no listeners currently addressed.</entry>
	</row>
	<row>
	<entry>EADR</entry>
	<entry>3</entry>
	<entry>The interface board has failed to address itself properly
	before starting an io operation.</entry>
	</row>
	<row>
	<entry>EARG</entry>
	<entry>4</entry>
	<entry>One or more arguments to the function call were invalid.</entry>
	</row>
	<row>
	<entry>ESAC</entry>
	<entry>5</entry>
	<entry>The interface board needs to be system controller, but is not.
	</entry>
	</row>
	<row>
	<entry>EABO</entry>
	<entry>6</entry>
	<entry>A read or write of data bytes has been aborted, possibly due
	to a timeout or reception of a device clear command.</entry>
	</row>
	<row>
	<entry>ENEB</entry>
	<entry>7</entry>
	<entry>The GPIB interface board does not exist, its driver is not
	loaded, or it is not configured properly.</entry>
	</row>
	<row>
	<entry>EDMA</entry>
	<entry>8</entry>
	<entry>Not used (DMA error), included for compatibility purposes.</entry>
	</row>
	<row>
	<entry>EOIP</entry>
	<entry>10</entry>
	<entry>Function call can not proceed due to an asynchronous IO operation
	(ibrda(), ibwrta(), or ibcmda()) in progress.</entry>
	</row>
	<row>
	<entry>ECAP</entry>
	<entry>11</entry>
	<entry>Incapable of executing function call, due the GPIB board lacking
	the capability, or
	the capability being disabled in software.</entry>
	</row>
	<row>
	<entry>EFSO</entry>
	<entry>12</entry>
	<entry>File system error.  ibcnt/ibcntl will be set to the value of errno.</entry>
	</row>
	<row>
	<entry>EBUS</entry>
	<entry>14</entry>
	<entry>An attempt to write command bytes to the bus has timed out.</entry>
	</row>
	<row>
	<entry>ESTB</entry>
	<entry>15</entry>
	<entry>One or more serial poll status bytes have been lost.  This can
	occur due to
	too many status bytes accumulating (through automatic serial polling)
	without being read.</entry>
	</row>
	<row>
	<entry>ESRQ</entry>
	<entry>16</entry>
	<entry>The serial poll request service line is stuck on.  This can occur
	if a physical device on the bus requests service, but its GPIB address has
	not been opened
	(via ibdev() for example) by any process.  Thus the automatic serial
	polling routines are unaware of the device's existence and will never
	serial poll it.
	</entry>
	</row>
	<row>
	<entry>ETAB</entry>
	<entry>20</entry>
	<entry>This error can be returned by ibevent(), FindLstn(), or
	FindRQS().  See their descriptions for more information.</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
</refentry>

<refentry ID="reference-globals-ibsta">
<refmeta>
	<refentrytitle>ibsta</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsta</refname>
	<refpurpose>holds status</refpurpose>
</refnamediv>
<refsynopsisdiv>
<programlisting>
#include &lt;gpib/ib.h&gt;

volatile int ibsta;
</programlisting>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibsta is set whenever a function from the 'traditional' or 'multidevice'
	API is called.  Each of the bits in ibsta has a different meaning, summarized
	in the following table:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>ibsta Bits</title>
	<tgroup COLS="4" ALIGN="left" >
	<thead>
	<row>
	<entry>bit</entry>
	<entry>value (hexadecimal)</entry>
	<entry>meaning</entry>
	<entry>used for board/device</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>DCAS</entry>
	<entry>0x1</entry>
	<entry>DCAS is set when a board receives the device clear command
	(that is, the
	SDC or DCL <link LINKEND="reference-command-bytes">command byte</link>).
	It is cleared on the next 'traditional' or
	'multidevice' function call following ibwait(), or following a read
	or write (ibrd(), ibwrt(), Receive(), etc.).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>DTAS</entry>
	<entry>0x2</entry>
	<entry>DTAS is set when a board has received a device trigger command
	(that is,
	the GET <link LINKEND="reference-command-bytes">command byte</link>).
	It is cleared on the next 'traditional' or
	'multidevice' function call following ibwait(), or following a read
	or write (ibrd(), ibwrt(), Receive(), etc.).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>LACS</entry>
	<entry>0x4</entry>
	<entry>Board is currently addressed as a listener.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>TACS</entry>
	<entry>0x8</entry>
	<entry>Board is currently addressed as talker.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>ATN</entry>
	<entry>0x10</entry>
	<entry>The ATN line is asserted.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>CIC</entry>
	<entry>0x20</entry>
	<entry>Board is controller-in-charge, so it is able to set the ATN line.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>REM</entry>
	<entry>0x40</entry>
	<entry>Board is in 'remote' state.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>LOK</entry>
	<entry>0x80</entry>
	<entry>Board is in 'lockout' state.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>CMPL</entry>
	<entry>0x100</entry>
	<entry>I/O operation is complete.  Useful for determining when
	an asynchronous io operation (ibrda(), ibwrta(), etc) has
	completed.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>EVENT</entry>
	<entry>0x200</entry>
	<entry>One or more clear, trigger, or interface clear events have been received,
	and are available in the event queue (see ibevent()).</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>SPOLL</entry>
	<entry>0x400</entry>
	<entry>If this bit is enabled (see ibconfig()), it is set when the board is
	serial polled.  The SPOLL bit is cleared when the board requests service
	(see ibrsv()) or you call ibwait() on the board with SPOLL in the wait mask.
	</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>RQS</entry>
	<entry>0x800</entry>
	<entry>RQS indicates that the device has requested service, and one
	or more status bytes are available for reading with ibrsp().</entry>
	<entry>device</entry>
	</row>
	<row>
	<entry>SRQI</entry>
	<entry>0x1000</entry>
	<entry>SRQI indicates that a device connected to the board is asserting
	the SRQ line.  It
	is only set if the board is the controller-in-charge.  If
	automatic serial polling is enabled, SRQI will generally be cleared,
	since when a device requests service it will be automatically
	polled and then unassert SRQ.</entry>
	<entry>board</entry>
	</row>
	<row>
	<entry>END</entry>
	<entry>0x2000</entry>
	<entry>END is set if the last io operation ended with the EOI
	line asserted, and may be set on reception of the end-of-string character.
	The
	IbcEndBitIsNormal option of ibconfig() can be used to configure
	whether or not END should be set on reception of the eos character.
	</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>TIMO</entry>
	<entry>0x4000</entry>
	<entry>TIMO indicates that the last io operation or ibwait() timed out.</entry>
	<entry>board or device</entry>
	</row>
	<row>
	<entry>ERR</entry>
	<entry>0x8000</entry>
	<entry>ERR is set if the last 'traditional' or 'multidevice' function
	call failed.  The global variable <link LINKEND="reference-globals-iberr">iberr</link>
	 will be set indicate the
	cause of the error.</entry>
	<entry>board or device</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
</refentry>

</section>

<section>
<title>
	'Traditional' API Functions
</title>

<refentry ID="reference-function-ibdev">
<refmeta>
	<refentrytitle>ibdev</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibdev</refname>
	<refpurpose>open a device (device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibdev</function></funcdef>
		<paramdef>int <parameter>board_index</parameter></paramdef>
		<paramdef>int <parameter>pad</parameter></paramdef>
		<paramdef>int <parameter>sad</parameter></paramdef>
		<paramdef>int <parameter>timeout</parameter></paramdef>
		<paramdef>int <parameter>send_eoi</parameter></paramdef>
		<paramdef>int <parameter>eos</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibdev() is used to obtain a device descriptor, which can then be used by
	other functions in the library.  The argument <parameter>board_index</parameter>
	specifies which GPIB interface board the device is connected to.
	The <parameter>pad</parameter> and <parameter>sad</parameter> arguments specify
	the GPIB address of the device to be opened (see <link LINKEND="reference-function-ibpad">
	ibpad()</link> and <link LINKEND="reference-function-ibsad">ibsad()</link>).
	The timeout for io operations is specified by <parameter> timeout </parameter>
	(see <link LINKEND="reference-function-ibtmo">ibtmo()</link>). If
	<parameter>send_eoi</parameter> is nonzero, then the EOI
	line will be asserted with the last byte sent during writes (see
	<link LINKEND="reference-function-ibeot">ibeot()</link>).
	Finally, the <parameter>eos</parameter>
	argument specifies the end-of-string character and whether or not its
	reception should terminate reads (see <link LINKEND="reference-function-ibeos">
	ibeos()</link>).
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	If sucessful, returns a (non-negative) device descriptor.  On failure, -1 is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibeos">
<refmeta>
	<refentrytitle>ibeos</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibeos</refname>
	<refpurpose>set end-of-string mode (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibeos</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>eosmode</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibeos() is used to set the end-of-string character and mode.  The least
	significant 8 bits of <parameter>eosmode</parameter> specify the
	eos character.  You may also bitwise-or one or more of the following
	bits to set the eos mode:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>End-of-String Mode Bits</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value (hexadecimal)</entry>
	<entry>meaning</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>REOS</entry>
	<entry>0x400</entry>
	<entry>Enable termination of reads when eos character is received.</entry>
	</row>
	<row>
	<entry>XEOS</entry>
	<entry>0x800</entry>
	<entry>Assert the EOI line whenever the eos character is sent during writes.</entry>
	</row>
	<row>
	<entry>BIN</entry>
	<entry>0x1000</entry>
	<entry>Match eos character using all 8 bits (instead of only looking at
	the 7 least significant bits).</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
		The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibeot">
<refmeta>
	<refentrytitle>ibeot</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibeot</refname>
	<refpurpose>assert EOI with last data byte (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibeot</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>send_eoi</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	If <parameter>send_eoi</parameter> is non-zero, then the EOI
	line will be asserted with the last byte sent by
	calls to <link LINKEND="reference-function-ibwrt">ibwrt()</link>
	and related functions.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibpad">
<refmeta>
	<refentrytitle>ibpad</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibpad</refname>
	<refpurpose>set primary GPIB address (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibpad</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>pad</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibpad() sets the GPIB primary address to <parameter>pad</parameter>
	for the device or board specified by the descriptor <parameter>ud</parameter>.
	If <parameter>ud</parameter> is a device descriptor, then the setting is
	local to the descriptor (it does not affect the behaviour of calls using
	other descriptors, even if they refer to the same physical device).  If
	<parameter>ud</parameter> is a board descriptor, then the board's
	primary address is changed immediately, which is a global change affecting
	anything (even other processes) using the board.  Valid GPIB primary
	addresses are in the range from 0 to 30.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibrd">
<refmeta>
	<refentrytitle>ibrd</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibrd</refname>
	<refpurpose>read data bytes (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibrd</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>void* <parameter>buffer</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibrd() is used to read data bytes from a device or board.  The argument
	<parameter>ud</parameter> can be either a device or board descriptor.
	If <parameter>ud</parameter> is a device descriptor, then the library
	automatically handles addressing the device as talker and the interface
	board as listener before performing the read.  Up to
	<parameter>num_bytes</parameter> bytes
	are read into the user-supplied array <parameter>buffer</parameter>.  The
	read may be terminated by an end-of-string character (see
	<link LINKEND="reference-function-ibeos">ibeos()</link>), a
	timeout (see <link LINKEND="reference-function-ibtmo">ibtmo()</link>),
	or by the talker asserting the EOI line.
	</para>
	<para>
	After the ibrd() call, ibcnt and ibcntl are set to the number of bytes
	read.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibsad">
<refmeta>
	<refentrytitle>ibsad</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibsad</refname>
	<refpurpose>set secondary GPIB address (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibsad</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>sad</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibsad() sets the GPIB secondary address
	of the device or board specified by the descriptor <parameter>ud</parameter>.
	If <parameter>ud</parameter> is a device descriptor, then the setting is
	local to the descriptor (it does not affect the behaviour of calls using
	other descriptors, even if they refer to the same physical device).  If
	<parameter>ud</parameter> is a board descriptor, then the board's
	secondary address is changed immediately, which is a global change affecting
	anything (even other processes) using the board.
	</para>
	<para>
	This library follows NI's unfortunate convention of adding 0x60 hexadecimal (96
	decimal) to
	secondary addresses.  That is, if you wish to set the secondary address
	to 3, you should set <parameter>sad</parameter> to 0x63.  Setting
	<parameter>sad</parameter> to 0 disables the use of secondary addressing.
	Valid GPIB secondary addresses are in the range from 0 to 30 (which correspond
	to <parameter>sad</parameter> values of 0x60 to 0x7e).
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibtmo">
<refmeta>
	<refentrytitle>ibtmo</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibtmo</refname>
	<refpurpose>adjust io timeout (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibtmo</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>int <parameter>timeout</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibtmo() sets timeout for IO operations performed using the board
	or device descriptor
	<parameter>ud</parameter>.  The actual amount of time before
	a timeout occurs may be greater than the period specified, but
	never less.
	<parameter>timeout</parameter> is specified by using one of
	the following constants:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="0">
	<title>Timeout constants</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>constant</entry>
	<entry>value</entry>
	<entry>timeout</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>TNONE</entry>
	<entry>0</entry>
	<entry>Never timeout.</entry>
	</row>
	<row>
	<entry>T10us</entry>
	<entry>1</entry>
	<entry>10 microseconds</entry>
	</row>
	<row>
	<entry>T30us</entry>
	<entry>2</entry>
	<entry>30 microseconds</entry>
	</row>
	<row>
	<entry>T100us</entry>
	<entry>3</entry>
	<entry>100 microseconds</entry>
	</row>
	<row>
	<entry>T300us</entry>
	<entry>4</entry>
	<entry>300 microseconds</entry>
	</row>
	<row>
	<entry>T1ms</entry>
	<entry>5</entry>
	<entry>1 millisecond</entry>
	</row>
	<row>
	<entry>T3ms</entry>
	<entry>6</entry>
	<entry>3 milliseconds</entry>
	</row>
	<row>
	<entry>T10ms</entry>
	<entry>7</entry>
	<entry>10 milliseconds</entry>
	</row>
	<row>
	<entry>T30ms</entry>
	<entry>8</entry>
	<entry>30 milliseconds</entry>
	</row>
	<row>
	<entry>T100ms</entry>
	<entry>9</entry>
	<entry>100 milliseconds</entry>
	</row>
	<row>
	<entry>T300ms</entry>
	<entry>10</entry>
	<entry>300 milliseconds</entry>
	</row>
	<row>
	<entry>T1s</entry>
	<entry>11</entry>
	<entry>1 second</entry>
	</row>
	<row>
	<entry>T3s</entry>
	<entry>12</entry>
	<entry>3 seconds</entry>
	</row>
	<row>
	<entry>T10s</entry>
	<entry>13</entry>
	<entry>10 seconds</entry>
	</row>
	<row>
	<entry>T30s</entry>
	<entry>14</entry>
	<entry>30 seconds</entry>
	</row>
	<row>
	<entry>T100s</entry>
	<entry>15</entry>
	<entry>100 seconds</entry>
	</row>
	<row>
	<entry>T300s</entry>
	<entry>16</entry>
	<entry>300 seconds</entry>
	</row>
	<row>
	<entry>T1000s</entry>
	<entry>17</entry>
	<entry>1000 seconds</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

<refentry ID="reference-function-ibwrt">
<refmeta>
	<refentrytitle>ibwrt</refentrytitle>
	<manvolnum>3</manvolnum>
</refmeta>
<refnamediv>
	<refname>ibwrt</refname>
	<refpurpose>write data bytes (board or device)</refpurpose>
</refnamediv>
<refsynopsisdiv>
	<funcsynopsis>
	<funcsynopsisinfo>#include &lt;gpib/ib.h&gt;</funcsynopsisinfo>
	<funcprototype>
		<funcdef>int <function>ibwrt</function></funcdef>
		<paramdef>int <parameter>ud</parameter></paramdef>
		<paramdef>void* <parameter>buffer</parameter></paramdef>
		<paramdef>long <parameter>num_bytes</parameter></paramdef>
	</funcprototype>
	</funcsynopsis>
</refsynopsisdiv>
<refsect1>
	<title>
	Description
	</title>
	<para>
	ibwrt() is used to write data bytes to a device or board.  The argument
	<parameter>ud</parameter> can be either a device or board descriptor.
	If <parameter>ud</parameter> is a device descriptor, then the library
	automatically handles addressing the device as listener and the interface
	board as talker before performing the write.
	<parameter>num_bytes</parameter> bytes
	are written from the user-supplied array <parameter>buffer</parameter>.
	EOI may be asserted with the last byte sent or when the end-of-string
	character is sent (see <link LINKEND="reference-function-ibeos">
	ibeos()</link> and <link LINKEND="reference-function-ibeot">
	ibeot()</link>).  The write
	may be interrupted by a timeout (see <link LINKEND="reference-function-ibtmo">
	ibtmo()</link>).
	</para>
	<para>
	After the ibwrt() call, ibcnt and ibcntl are set to the number of bytes
	written.
	</para>
</refsect1>
<refsect1>
	<title>
	Return value
	</title>
	<para>
	The value of <link LINKEND="reference-globals-ibsta">ibsta</link> is returned.
	</para>
</refsect1>
</refentry>

</section>

</section>

<section ID="gpib-protocol">
<title>GPIB protocol</title>

<section ID="reference-command-bytes">
	<title>GPIB command bytes</title>
	<para>
	The meaning and values of the possible GPIB command bytes
	are as follows:
	</para>
	<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>GPIB command bytes</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>byte value (hexadecimal)</entry>
	<entry>name</entry>
	<entry>description</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>0x1</entry>
	<entry>GTL</entry>
	<entry>Go to local</entry>
	</row>
	<row>
	<entry>0x4</entry>
	<entry>SDC</entry>
	<entry>Selected device clear</entry>
	</row>
	<row>
	<entry>0x5</entry>
	<entry>PPC</entry>
	<entry>Parallel poll configure</entry>
	</row>
	<row>
	<entry>0x8</entry>
	<entry>GET</entry>
	<entry>Group execute trigger</entry>
	</row>
	<row>
	<entry>0x9</entry>
	<entry>TCT</entry>
	<entry>Take control</entry>
	</row>
	<row>
	<entry>0x11</entry>
	<entry>LLO</entry>
	<entry>Local lockout</entry>
	</row>
	<row>
	<entry>0x14</entry>
	<entry>DCL</entry>
	<entry>Device clear</entry>
	</row>
	<row>
	<entry>0x15</entry>
	<entry>PPU</entry>
	<entry>Parallel poll unconfigure</entry>
	</row>
	<row>
	<entry>0x18</entry>
	<entry>SPE</entry>
	<entry>Serial poll enable</entry>
	</row>
	<row>
	<entry>0x19</entry>
	<entry>SPD</entry>
	<entry>Serial poll disable</entry>
	</row>
	<row>
	<entry>0x20 to 0x3e</entry>
	<entry>MLA0 to MLA30</entry>
	<entry>My (primary) listen address 0 to 30</entry>
	</row>
	<row>
	<entry>0x3f</entry>
	<entry>UNL</entry>
	<entry>Unlisten</entry>
	</row>
	<row>
	<entry>0x40 to 0x5e</entry>
	<entry>MTA0 to MTA30</entry>
	<entry>My (primary) talk address 0 to 30</entry>
	</row>
	<row>
	<entry>0x5f</entry>
	<entry>UNT</entry>
	<entry>Untalk</entry>
	</row>
	<row>
	<entry>0x60 to 0x6f</entry>
	<entry>MSA0 to MSA15, also PPE</entry>
	<entry>When following a talk or listen address, this is
	'my secondary address' 0 to 15.  When following a parallel
	poll configure, this is 'parallel poll enable'.  For
	parallel poll enable, the least significant 3 bits
	of the command byte specify which DIO line the device
	should use to send its parallel poll response.  The
	fourth least significant bit (0x8)
	indicates the 'sense' or polarity the device should use
	when responding.
	</entry>
	</row>
	<row>
	<entry>0x70 to 0x7d</entry>
	<entry>MSA16 to MSA29, also PPD</entry>
	<entry>When following a talk or listen address, this is
	'my secondary address' 16 to 29.  When following a parallel
	poll configure, this is 'parallel poll disable'.</entry>
	</row>
	<row>
	<entry>0x7e</entry>
	<entry>MSA30</entry>
	<entry>My secondary address 30</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
	</para>
</section>

<section>
<title>GPIB bus lines</title>
<para>
Physically, the GPIB bus consists of 8 data lines, 3 handshaking
lines, and 5 control lines (and 8 ground
lines).  Brief descriptions
of how they are used follow:
</para>
<para>
	<table COLSEP="1" ROWSEP="1" ORIENT="port" PGWIDE="1">
	<title>GPIB bus lines</title>
	<tgroup COLS="3" ALIGN="left" >
	<thead>
	<row>
	<entry>bus line</entry>
	<entry>description</entry>
	<entry>pin number</entry>
	</row>
	</thead>
	<tbody>
	<row>
	<entry>DIO1 through DIO8</entry>
	<entry>Data input/output bits.  These 8 lines are used to read and write the 8 bits
	of a data or command byte that is being sent over the bus.</entry>
	<entry>DIO1 to DIO4 use pins 1 to 4, DIO5 to DIO8 use pins 13 to 16</entry>
	</row>
	<row>
	<entry>EOI</entry>
	<entry>End-or-identify.  This line is asserted with the last byte of
	data during a write, to indicate the end of the message.  It can
	also be asserted along with the ATN line to conduct a parallel poll.</entry>
	<entry>5</entry>
	</row>
	<row>
	<entry>DAV</entry>
	<entry>Data valid.  This is a handshaking line, used to signal that
	the value being sent with DIO1-DIO8 is valid.  During transfers the
	DIO1-DIO8 lines are set, then the DAV line is asserted after
	a delay called the 'T1 delay'.  The T1 delay lets the data lines
	settle to stable values before they are read.</entry>
	<entry>6</entry>
	</row>
	<row>
	<entry>NRFD</entry>
	<entry>Not ready for data.  NRFD is a handshaking line asserted by
	listeners to indicate
	they are not ready to receive a data byte.</entry>
	<entry>7</entry>
	</row>
	<row>
	<entry>NDAC</entry>
	<entry>Not data accepted.  NDAC is a handshaking line asserted by
	listeners to indicate
	they have not yet read the byte contained on the DIO lines.</entry>
	<entry>8</entry>
	</row>
	<row>
	<entry>IFC</entry>
	<entry>Interface clear.  The system controller can assert this line
	(it should be asserted for at least 100 microseconds) to reset
	the bus and make itself controller-in-charge.</entry>
	<entry>9</entry>
	</row>
	<row>
	<entry>SRQ</entry>
	<entry>Service request.  Devices on the bus can assert this line
	to request service from the controller-in-charge.  The controller
	can then poll the devices until it finds the device requesting
	service, and perform whatever action is necessary.</entry>
	<entry>10</entry>
	</row>
	<row>
	<entry>ATN</entry>
	<entry>Attention.  ATN is asserted to indicate that the DIO lines
	contain a <link LINKEND="reference-command-bytes">command byte</link>
	(as opposed to a data byte).  Also, it is asserted with EOI
	when conducting parallel polls.</entry>
	<entry>11</entry>
	</row>
	<row>
	<entry>REN</entry>
	<entry>Remote enable.  Asserted by the system controller to put
	devices into remote mode.  When REN is asserted, a device will
	enter remote mode when it is addressed by the controller.</entry>
	<entry>17</entry>
	</row>
	</tbody>
	</tgroup>
	</table>
</para>
</section>

</section>

&license

</article>

